// $Id: basic_postfix_emitter.h,v 1.2 2014/02/25 21:43:13 david Exp $ -*- c++ -*-
#ifndef __CDK9_GENERATOR_POSTFIX_H__
#define __CDK9_GENERATOR_POSTFIX_H__

#include <iostream>
#include <string>
#include <memory>
#include <cdk/compiler.h>

namespace cdk {

  /**
   * The postfix code emitter defines an interface to be used by semantic
   * analysers, as defined by the strategy design pattern. Specific
   * implementations will provide the realization of the postfix commands for a
   * particular target machine.
   *
   * <h3>Rotation and shift instructions</h3>
   * Shift and rotation operations have as maximum value the number of bits of the
   * underlying processor register (32 bits in a ix86-family processor). Safe
   * operation for values above is not guaranteed.
   *
   * These operations use two values from the stack: the value at the top specifies
   * the number of bits to rotate/shift; the second from the top is the value to be
   * rotated/shifted.
   *
   * <h3>Logical instructions</h3>
   *
   * Logical instructions perform logical operations using the elements at the
   * top of the stack. Arguments are taken from the stack, the result is put on the
   * stack.
   *
   * <h3>Type conversion instructions</h3>
   *
   * Type conversion instructions perform elementary type conversions. The conversions
   * are from and to integers and simple and double precision floating point values.
   *
   * <h3>Integer comparison instructions</h3>
   *
   * The comparison instructions are binary operations that leave at the top of the
   * stack 0 (zero) or 1 (one), depending on the result result of the comparison:
   * respectively, <tt>false</tt> or <tt>true</tt>. The value may be directly used
   * to perform conditional jumps (e.g., JZ, JNZ), that use the value of the top of
   * the stack instead of relying on special processor registers (<i>flags</i>).
   *
   * <h3>Function definition instructions</h3>
   *
   * In a stack machine the arguments for a function call are already in the stack.
   * Thus, it is not necessary to put them there (it is enough not to remove them).
   * When building functions that conform to the C calling convetions,
   * those arguments are destroyed by the caller, <i>after</i> the return of the
   * callee, using <tt>TRASH</tt>, stating the total size (i.e., for all
   * arguments). Regarding the callee, it must create a distinct activation
   * register <tt>ENTER</tt> or <tt>START</tt>) and, when no longer
   * needed, destroy it (<tt>LEAVE</tt>). The latter action must be
   * performed immediately before returning control to the caller.
   *
   * Similarly, to return values from a function, the callee must call
   * <tt>POP</tt> to store the return value in the accumulator register, so
   * that it survives the destruction of the invocation context. The caller must
   * call <tt>PUSH</tt>, to put the accumulator in the stack. An analogous
   * procedure is valid for <tt>DPOP/DPUSH</tt> (for double precision floating point return
   * values).
   *
   * <h3>Addressing instructions</h3>
   *
   * Note [*4*] that these operations (ADDR, LOCAL) put at the top of the stack the
   * symbol's address, independently of its origin. O endereço pode posteriormente
   * ser utilizado como ponteiro, obtido o valor nesse endereço (LOAD) ou guardar
   * um valor nesse endereço (STORE). No entanto, nas duas últimas situações,
   * devido à frequência com que ocorrem e o número de ciclos de relógio que levam
   * a executar, podem ser substituídas com vantagem pela operações descritas em
   * [*10*].
   *
   * "Quick opcodes" are shortcuts for groups of operations commonly used
   * together. These opcodes may be made efficient by implementing them in
   * different ways than the original set of high-level operations would suggest,
   * i.e., the code generated by <tt>ADDRV</tt> may be more efficient than
   * the code generated by <tt>ADDR</tt> followed by <tt>LOAD</tt>.
   * Nevertheless, the outcome is the same.
   *
   * <h3>Load instructions</h3>
   *
   * The load instructions assume that the top of the stack contains an address
   * pointing to the data to be read. Each load instruction will replace the
   * address at the top of the stack with the contents of the position it points
   * to. Load instructions differ only in what they load.
   *
   * <h3>Store instructions</h3>
   *
   * Store instructions assume the stack contains at the top the address where
   * data is to be stored. That data is in the stack, immediately after (below) the
   * address. Store instructions differ only in what they store.
   *
   * <h3>Labels</h3>
   *
   * In a declaration of a symbol common to more than one module, other modules may
   * also contain common or external declarations. Nevertheless, only one
   * initialized declaration is allowed. Declarations need not be associated with
   * any particular segments.
   *
   * In a declaration common to several modules, any number of modules may
   * contain common or external declarations, but only one of them may
   * contain an initialized declaration. A declaration does not need to be
   * specified in a specific segment.
   */
  class basic_postfix_emitter {

    std::shared_ptr<compiler> &_compiler;

  protected:

    inline basic_postfix_emitter(std::shared_ptr<compiler> &compiler) :
        _compiler(compiler) {
    }

    inline std::ostream &os() {
      return *_compiler->ostream();
    }

    inline bool debug() {
      return _compiler->debug();
    }

  public:
    /**
     * Destructor: the only action is to flush the output stream.
     */
    virtual ~basic_postfix_emitter() {
      os().flush();
      _compiler = nullptr;
    }

  public:
    virtual void ORIG(int) = 0;
    virtual void EQU(std::string, int) = 0;
    virtual void WORD(std::string, int) = 0;
    virtual void STR(std::string, std::string) = 0;
    virtual void TAB(std::string, int) = 0;
    virtual void ADD() = 0;
    virtual void ADDC() = 0;
    virtual void AND() = 0;
    virtual void BR(std::string) = 0;
    virtual void BRCOND(std::string, std::string) = 0;
    virtual void CALL(std::string) = 0;
    virtual void CALLCOND(std::string, std::string) = 0;
    virtual void CLC() = 0;
    virtual void CMC() = 0;
    virtual void CMP() = 0;
    virtual void COM() = 0;
    virtual void DEC() = 0;
    virtual void DIV() = 0;
    virtual void DSI() = 0;
    virtual void ENI() = 0;
    virtual void INC() = 0;
    virtual void INT(int) = 0;
    virtual void JMP(std::string) = 0;
    virtual void JMPZ(std::string) = 0;
    virtual void JMPN(std::string) = 0;
    virtual void JMPCOND(std::string, std::string) = 0;
    virtual void MOD() = 0;
    virtual void MOV(std::string, std::string) = 0;
    virtual void MUL() = 0;
    virtual void MVBH() = 0;
    virtual void MVBL() = 0;
    virtual void NEG() = 0;
    virtual void NOP() = 0;
    virtual void OR() = 0;
    virtual void POP() = 0;
    virtual void PUSH(int value) = 0;
    virtual void RET() = 0;
    virtual void RETN(int) = 0;
    virtual void ROL(int) = 0;
    virtual void ROLC(int) = 0;
    virtual void ROR(int) = 0;
    virtual void RORC(int) = 0;
    virtual void RTI() = 0;
    virtual void SHL(int) = 0;
    virtual void SHLA(int) = 0;
    virtual void SHR(int) = 0;
    virtual void SHRA(int) = 0;
    virtual void STC() = 0;
    virtual void SUB() = 0;
    virtual void SUBB() = 0;
    virtual void TEST() = 0;
    virtual void XCH() = 0;
    virtual void XOR() = 0;
    virtual void LABEL(std::string) = 0;
    virtual void TRASH(int value) = 0;
    virtual void LOAD() = 0;
    virtual void ADDR(std::string) = 0;
    virtual void STORE() = 0;
    virtual void DUP() = 0;
  };

} // namespace cdk

#endif
